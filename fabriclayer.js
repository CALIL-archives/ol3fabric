// Generated by CoffeeScript 1.9.3
var FabricLayer, addFabricObject, fabricInit,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

FabricLayer = (function(superClass) {
  extend(FabricLayer, superClass);

  FabricLayer.prototype.map = null;

  FabricLayer.prototype.geojson = null;

  function FabricLayer(options) {
    FabricLayer.__super__.constructor.call(this, options);
    this.on('postcompose', this.postcompose_, this);
    this.setSource(new ol.source.Vector());
    this.geojson = options.geojson;
  }

  FabricLayer.prototype.postcompose_ = function(event) {
    var context, oneMeterPx, pixelRatio, r, r2, resolutionAtCoords, view;
    if (this.map == null) {
      return;
    }
    context = event.context;
    pixelRatio = event.frameState.pixelRatio;
    view = this.map.getView();
    resolutionAtCoords = view.getProjection().getPointResolution(event.frameState.viewState.resolution, view.getCenter());
    oneMeterPx = (1 / resolutionAtCoords) * pixelRatio;
    r = event.frameState.viewState.rotation;
    r2 = this.rotation * Math.PI / 180;
    if (window.canvas == null) {
      this.map.on('moveend', (function(_this) {
        return function() {
          console.log('moveend');
          return addFabricObject(_this);
        };
      })(this));
      fabricInit(context, this, oneMeterPx);
    }
    return canvas.renderAllOnTop();
  };

  return FabricLayer;

})(ol.layer.Vector);

fabricInit = (function(_this) {
  return function(context, layer, oneMeterPx) {
    window.canvas = new fabric.Canvas(context.canvas, {
      width: context.canvas.width,
      height: context.canvas.height,
      renderOnAddRemove: true
    });
    window.onresize = function() {
      canvas.setWidth(document.documentElement.clientWidth);
      return canvas.setHeight(document.documentElement.clientHeight);
    };
    fabric.Object.prototype.scaleX = 1;
    fabric.Object.prototype.scaleY = 1;
    fabric.Object.prototype.originX = 'center';
    fabric.Object.prototype.originY = 'center';
    fabric.Object.prototype.transparentCorners = true;
    fabric.Object.prototype.cornerColor = "#488BD4";
    fabric.Object.prototype.borderOpacityWhenMoving = 0.8;
    fabric.Object.prototype.cornerSize = 10;
    canvas._renderAll = canvas.renderAll;
    canvas.renderAll = function() {
      return layer.changed();
    };
    canvas._renderTop = canvas.renderTop;
    canvas.renderTop = function() {
      return layer.changed();
    };
    return canvas.renderAllOnTop = function() {
      var activeGroup, canvasToDrawOn;
      canvasToDrawOn = this.contextTop;
      activeGroup = this.getActiveGroup();
      this.clearContext(this.contextTop);
      this.fire('before:render');
      if (this.clipTo) {
        fabric.util.clipContext(this, canvasToDrawOn);
      }
      this._renderBackground(canvasToDrawOn);
      this._renderObjects(canvasToDrawOn, activeGroup);
      this._renderActiveGroup(canvasToDrawOn, activeGroup);
      if (this.selection && this._groupSelector) {
        this._drawSelection();
      }
      if (this.clipTo) {
        canvasToDrawOn.restore();
      }
      this._renderOverlay(canvasToDrawOn);
      if (this.controlsAboveOverlay && this.interactive) {
        this.drawControls(canvasToDrawOn);
      }
      this.fire('after:render');
      return this;
    };
  };
})(this);

addFabricObject = function(layer) {
  var coordinates, feature, height, i, len, object, ref, results, width, x1, x2, y1, y2;
  canvas.clear();
  ref = layer.geojson.features;
  results = [];
  for (i = 0, len = ref.length; i < len; i++) {
    feature = ref[i];
    coordinates = feature.geometry.coordinates[0];
    x1 = layer.map.getPixelFromCoordinate(coordinates[1])[0];
    y1 = layer.map.getPixelFromCoordinate(coordinates[1])[1];
    x2 = layer.map.getPixelFromCoordinate(coordinates[3])[0];
    y2 = layer.map.getPixelFromCoordinate(coordinates[3])[1];
    width = x2 - x1;
    height = y2 - y1;
    object = new fabric.Rect({
      left: x1 + width / 2,
      top: y1 + height / 2,
      fill: feature.properties.color,
      width: width,
      height: height,
      angle: 0
    });
    results.push(canvas.add(object));
  }
  return results;
};

//# sourceMappingURL=fabriclayer.js.map
