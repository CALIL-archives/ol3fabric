// Generated by CoffeeScript 1.9.3
var FabricLayer,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

FabricLayer = (function(superClass) {
  extend(FabricLayer, superClass);

  FabricLayer.prototype.map = null;

  FabricLayer.prototype.context = null;

  FabricLayer.prototype.canvas = null;

  FabricLayer.prototype.geojson = null;

  FabricLayer.prototype.angle = 0;

  function FabricLayer(options) {
    FabricLayer.__super__.constructor.call(this, options);
    this.on('postcompose', this.postcompose_, this);
    this.setSource(new ol.source.Vector());
    this.geojson = options.geojson;
  }

  FabricLayer.prototype.setAngle = function(angle) {
    this.angle = angle;
    return this.changed();
  };

  FabricLayer.prototype.postcompose_ = function(event) {
    var oneMeterPx, pixelRatio, r, r2, resolutionAtCoords, view;
    if (this.map == null) {
      return;
    }
    this.context = event.context;
    pixelRatio = event.frameState.pixelRatio;
    view = this.map.getView();
    resolutionAtCoords = view.getProjection().getPointResolution(event.frameState.viewState.resolution, view.getCenter());
    oneMeterPx = (1 / resolutionAtCoords) * pixelRatio;
    r = event.frameState.viewState.rotation;
    r2 = this.rotation * Math.PI / 180;
    if (this.canvas == null) {
      this.map.on('moveend', (function(_this) {
        return function() {
          console.log('moveend');
          return _this.addFabricObject();
        };
      })(this));
      this.fabricInit();
    }
    return this.canvas.renderAllOnTop();
  };

  FabricLayer.prototype.fabricInit = function() {
    this.canvas = new fabric.Canvas(this.context.canvas, {
      width: this.context.canvas.width,
      height: this.context.canvas.height,
      renderOnAddRemove: true
    });
    window.onresize = (function(_this) {
      return function() {
        _this.canvas.setWidth(document.documentElement.clientWidth);
        return _this.canvas.setHeight(document.documentElement.clientHeight);
      };
    })(this);
    this.canvas.on('object:modified', (function(_this) {
      return function() {
        return console.log('object:modified');
      };
    })(this));
    fabric.Object.prototype.scaleX = 1;
    fabric.Object.prototype.scaleY = 1;
    fabric.Object.prototype.transparentCorners = true;
    fabric.Object.prototype.cornerColor = "#488BD4";
    fabric.Object.prototype.borderOpacityWhenMoving = 0.8;
    fabric.Object.prototype.cornerSize = 10;
    this.canvas._renderAll = this.canvas.renderAll;
    this.canvas.renderAll = (function(_this) {
      return function() {
        return _this.changed();
      };
    })(this);
    this.canvas._renderTop = this.canvas.renderTop;
    this.canvas.renderTop = (function(_this) {
      return function() {
        return _this.changed();
      };
    })(this);
    return this.canvas.renderAllOnTop = function() {
      var activeGroup, canvasToDrawOn;
      canvasToDrawOn = this.contextTop;
      activeGroup = this.getActiveGroup();
      this.clearContext(this.contextTop);
      this.fire('before:render');
      if (this.clipTo) {
        fabric.util.clipContext(this, canvasToDrawOn);
      }
      this._renderBackground(canvasToDrawOn);
      this._renderObjects(canvasToDrawOn, activeGroup);
      this._renderActiveGroup(canvasToDrawOn, activeGroup);
      if (this.selection && this._groupSelector) {
        this._drawSelection();
      }
      if (this.clipTo) {
        canvasToDrawOn.restore();
      }
      this._renderOverlay(canvasToDrawOn);
      if (this.controlsAboveOverlay && this.interactive) {
        this.drawControls(canvasToDrawOn);
      }
      this.fire('after:render');
      return this;
    };
  };

  FabricLayer.prototype.addFabricObject = function() {
    var c, coordinate, coordinates, feature, i, j, len, len1, new_cordinates, object, ref, results;
    this.canvas.clear();
    ref = this.geojson.features;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      feature = ref[i];
      coordinates = feature.geometry.coordinates[0];
      new_cordinates = [];
      for (j = 0, len1 = coordinates.length; j < len1; j++) {
        coordinate = coordinates[j];
        c = this.map.getPixelFromCoordinate(coordinate);
        new_cordinates.push({
          x: c[0],
          y: c[1]
        });
      }
      console.log(new_cordinates);
      object = new fabric.Polygon(new_cordinates, {
        fill: feature.properties.color
      });
      results.push(this.canvas.add(object));
    }
    return results;
  };

  FabricLayer.prototype.rotationToAngle = function(rotation) {
    return rotation / 1.57 * 90;
  };

  return FabricLayer;

})(ol.layer.Vector);

//# sourceMappingURL=fabriclayer.js.map
